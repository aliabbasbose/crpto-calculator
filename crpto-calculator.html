<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4-Hour Crypto Prediction Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        :root {
            --primary: #3498db;
            --success: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            margin: 0;
            padding: 20px;
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .header {
            background: var(--dark);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
        }
        .header p {
            margin: 5px 0 0;
            opacity: 0.8;
            font-size: 16px;
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 20px;
            background: var(--light);
            border-bottom: 1px solid #ddd;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
            color: var(--dark);
        }
        select, input, button {
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        button {
            background: var(--primary);
            color: white;
            cursor: pointer;
            border: none;
            transition: all 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        button:disabled {
            background: var(--gray);
            cursor: not-allowed;
            opacity: 0.7;
            transform: none !important;
        }
        .btn-success {
            background: var(--success);
        }
        .btn-danger {
            background: var(--danger);
        }
        .btn-warning {
            background: var(--warning);
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 350px;
            min-height: 500px;
        }
        .chart-container {
            padding: 20px;
            position: relative;
        }
        #priceChart {
            width: 100% !important;
            height: 450px !important;
        }
        .sidebar {
            background: #f8f9fa;
            border-left: 1px solid #eee;
            padding: 20px;
            overflow-y: auto;
        }
        .panel {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin: 0 0 15px;
            color: var(--dark);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .panel-title svg {
            width: 20px;
            height: 20px;
        }
        #coinList {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 5px;
        }
        .coin-item {
            padding: 10px;
            border-radius: 6px;
            background: white;
            border: 1px solid #eee;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 14px;
        }
        .coin-item:hover {
            border-color: var(--primary);
        }
        .coin-item.selected {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        #alerts {
            max-height: 400px;
            overflow-y: auto;
        }
        .alert {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            animation: fadeIn 0.5s;
            border-left: 4px solid transparent;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .alert-buy {
            background: rgba(46, 204, 113, 0.1);
            border-left-color: var(--success);
        }
        .alert-sell {
            background: rgba(231, 76, 60, 0.1);
            border-left-color: var(--danger);
        }
        .alert-neutral {
            background: rgba(52, 152, 219, 0.1);
            border-left-color: var(--primary);
        }
        .alert-coin {
            font-weight: bold;
            color: var(--dark);
        }
        .alert-price {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.05);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 14px;
        }
        .alert-reason {
            font-size: 13px;
            color: #666;
            margin-top: 5px;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--dark);
            color: white;
            font-size: 14px;
        }
        #connectionStatus {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--gray);
        }
        .status-indicator.connected {
            background: var(--success);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #lastUpdate {
            opacity: 0.8;
        }
        .empty-state {
            text-align: center;
            padding: 30px;
            color: var(--gray);
        }
        .search-box {
            position: relative;
            margin-bottom: 15px;
        }
        .search-box input {
            padding-left: 40px;
            width: 100%;
        }
        .search-box svg {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            opacity: 0.6;
        }
        .timeframe-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .timeframe-btn {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            background: white;
            color: var(--dark);
            border: 1px solid #ddd;
        }
        .timeframe-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>4-Hour Crypto Prediction Dashboard</h1>
            <p>Analyzing market trends using Binance API with 4-hour candles</p>
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <label for="coinSearch">Search Cryptocurrencies</label>
                <div class="search-box">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <input type="text" id="coinSearch" placeholder="BTC, ETH, SOL...">
                </div>
            </div>
            
            <div class="control-group">
                <label>Timeframe</label>
                <div class="timeframe-selector">
                    <button class="timeframe-btn active" data-interval="4h">4H</button>
                    <button class="timeframe-btn" data-interval="1d">1D</button>
                    <button class="timeframe-btn" data-interval="1w">1W</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Actions</label>
                <div style="display: flex; gap: 10px;">
                    <button id="loadCoinsBtn" class="btn-warning">
                        <span id="loadCoinsText">Load Cryptos</span>
                        <span id="loadCoinsSpinner" class="loading" style="display: none;"></span>
                    </button>
                    <button id="startBtn" class="btn-success" disabled>
                        <span>Start</span>
                        <span class="loading" style="display: none;"></span>
                    </button>
                    <button id="stopBtn" class="btn-danger" disabled>
                        <span>Stop</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="content">
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            
            <div class="sidebar">
                <div class="panel">
                    <div class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                        <span>Selected Coins</span>
                    </div>
                    <div id="selectedCoins" class="empty-state">
                        No coins selected
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                        </svg>
                        <span>Live Signals</span>
                    </div>
                    <div id="alerts" class="empty-state">
                        Waiting for data...
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                        </svg>
                        <span>Available Coins</span>
                    </div>
                    <div id="coinList" class="empty-state">
                        Click "Load Cryptos" to begin
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div id="connectionStatus">
                <div class="status-indicator"></div>
                <span id="statusText">Disconnected</span>
            </div>
            <div id="lastUpdate"></div>
        </div>
    </div>

    <audio id="alertSound">
        <source src="https://assets.mixkit.co/active_storage/sfx/2570/2570-preview.mp3" type="audio/mpeg">
    </audio>

    <script>
        // ===== CONFIGURATION =====
        const BINANCE_API = "https://api.binance.com/api/v3";
        let allSymbols = [];
        let selectedSymbols = [];
        let priceData = {};
        let chart = null;
        let updateInterval = null;
        let currentInterval = "4h";
        let isMonitoring = false;

        // ===== DOM ELEMENTS =====
        const coinSearchEl = document.getElementById('coinSearch');
        const loadCoinsBtn = document.getElementById('loadCoinsBtn');
        const loadCoinsText = document.getElementById('loadCoinsText');
        const loadCoinsSpinner = document.getElementById('loadCoinsSpinner');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const coinListEl = document.getElementById('coinList');
        const selectedCoinsEl = document.getElementById('selectedCoins');
        const alertsEl = document.getElementById('alerts');
        const statusTextEl = document.getElementById('statusText');
        const lastUpdateEl = document.getElementById('lastUpdate');
        const statusIndicator = document.querySelector('.status-indicator');
        const alertSound = document.getElementById('alertSound');
        const timeframeBtns = document.querySelectorAll('.timeframe-btn');

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', init);
        
        function init() {
            // Event listeners
            loadCoinsBtn.addEventListener('click', fetchAllCryptos);
            startBtn.addEventListener('click', startMonitoring);
            stopBtn.addEventListener('click', stopMonitoring);
            coinSearchEl.addEventListener('input', filterCoins);
            
            // Timeframe selection
            timeframeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    timeframeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentInterval = btn.dataset.interval;
                    if (isMonitoring) {
                        restartMonitoring();
                    }
                });
            });
            
            // Initial connection check
            checkConnection();
        }

        // ===== CONNECTION MANAGEMENT =====
        async function checkConnection() {
            try {
                updateStatus("Connecting to Binance API...");
                const response = await axios.get(${BINANCE_API}/ping, { timeout: 5000 });
                
                if (response.data) {
                    statusIndicator.classList.add('connected');
                    updateStatus("Connected to Binance API");
                    return true;
                }
            } catch (error) {
                console.error("Connection error:", error);
                updateStatus(Connection error: ${error.message});
                statusIndicator.classList.remove('connected');
                return false;
            }
        }

        // ===== DATA FETCHING =====
        async function fetchAllCryptos() {
            if (!await checkConnection()) return;
            
            showLoading(loadCoinsText, loadCoinsSpinner, "Loading...");
            loadCoinsBtn.disabled = true;
            
            try {
                const response = await axios.get(${BINANCE_API}/exchangeInfo);
                allSymbols = response.data.symbols
                    .filter(s => s.status === 'TRADING' && s.symbol.endsWith('USDT'))
                    .map(s => s.symbol.replace('USDT', ''));
                
                renderCoinList();
                updateStatus(Loaded ${allSymbols.length} trading pairs);
                startBtn.disabled = false;
            } catch (error) {
                console.error("Failed to load cryptocurrencies:", error);
                updateStatus(Error: ${error.message});
                showErrorInCoinList();
            } finally {
                showLoading(loadCoinsText, loadCoinsSpinner, "Load Cryptos", false);
                loadCoinsBtn.disabled = false;
            }
        }

        async function fetchHistoricalData(symbol) {
            try {
                const response = await axios.get(${BINANCE_API}/klines, {
                    params: {
                        symbol: ${symbol}USDT,
                        interval: currentInterval,
                        limit: 100
                    },
                    timeout: 10000
                });
                
                return response.data.map(kline => ({
                    time: new Date(kline[0]),
                    open: parseFloat(kline[1]),
                    high: parseFloat(kline[2]),
                    low: parseFloat(kline[3]),
                    close: parseFloat(kline[4]),
                    volume: parseFloat(kline[5])
                }));
            } catch (error) {
                console.error(Error fetching ${symbol} data:, error);
                return null;
            }
        }

        async function fetchLatestPrice(symbol) {
            try {
                const response = await axios.get(${BINANCE_API}/ticker/24hr, {
                    params: { symbol: ${symbol}USDT },
                    timeout: 5000
                });
                
                return {
                    price: parseFloat(response.data.lastPrice),
                    change: parseFloat(response.data.priceChangePercent),
                    volume: parseFloat(response.data.volume),
                    time: new Date(response.data.closeTime)
                };
            } catch (error) {
                console.error(Error fetching ${symbol} price:, error);
                return null;
            }
        }

        // ===== MONITORING FUNCTIONS =====
        async function startMonitoring() {
            if (isMonitoring || selectedSymbols.length === 0) return;
            
            isMonitoring = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            loadCoinsBtn.disabled = true;
            
            updateStatus("Initializing monitoring...");
            
            // Clear existing data
            priceData = {};
            alertsEl.innerHTML = '<div class="empty-state">Loading historical data...</div>';
            
            // Load historical data for selected symbols
            try {
                const promises = selectedSymbols.map(symbol => fetchHistoricalData(symbol));
                const historicalResults = await Promise.all(promises);
                
                // Process historical data
                selectedSymbols.forEach((symbol, index) => {
                    if (historicalResults[index]) {
                        priceData[symbol] = historicalResults[index];
                    }
                });
                
                // Then fetch latest prices
                await updatePrices();
                
                // Start periodic updates
                startUpdateInterval();
                
                updateStatus("Monitoring active");
            } catch (error) {
                console.error("Start monitoring error:", error);
                updateStatus(Error: ${error.message});
                stopMonitoring();
            }
        }

        function restartMonitoring() {
            if (isMonitoring) {
                stopMonitoring();
                setTimeout(startMonitoring, 1000);
            }
        }

        function stopMonitoring() {
            clearInterval(updateInterval);
            isMonitoring = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            loadCoinsBtn.disabled = false;
            
            updateStatus("Monitoring stopped");
        }

        function startUpdateInterval() {
            clearInterval(updateInterval);
            updatePrices(); // Initial update
            
            // Set interval based on current timeframe
            let intervalTime;
            switch (currentInterval) {
                case "4h": intervalTime = 4 * 60 * 60 * 1000; break; // 4 hours
                case "1d": intervalTime = 24 * 60 * 60 * 1000; break; // 1 day
                case "1w": intervalTime = 7 * 24 * 60 * 60 * 1000; break; // 1 week
                default: intervalTime = 4 * 60 * 60 * 1000;
            }
            
            // Update every 4 hours (for 4h timeframe) or more frequently for testing
            updateInterval = setInterval(updatePrices, Math.min(intervalTime, 5 * 60 * 1000));
        }

        async function updatePrices() {
            if (!isMonitoring) return;
            
            updateStatus("Updating prices...");
            lastUpdateEl.textContent = Updating: ${new Date().toLocaleTimeString()};
            
            try {
                const promises = selectedSymbols.map(symbol => fetchLatestPrice(symbol));
                const results = await Promise.all(promises);
                
                // Process results
                results.forEach((data, index) => {
                    const symbol = selectedSymbols[index];
                    if (!data || !priceData[symbol]) return;
                    
                    // Check if we have a new candle (based on timeframe)
                    const lastCandle = priceData[symbol][priceData[symbol].length - 1];
                    const candleTime = getCandleStartTime(data.time);
                    
                    if (candleTime > getCandleStartTime(lastCandle.time)) {
                        // New candle - add to history
                        priceData[symbol].push({
                            time: candleTime,
                            open: data.price,
                            high: data.price,
                            low: data.price,
                            close: data.price,
                            volume: data.volume
                        });
                        
                        // Keep only last 100 candles
                        if (priceData[symbol].length > 100) {
                            priceData[symbol].shift();
                        }
                    } else {
                        // Update current candle
                        lastCandle.close = data.price;
                        lastCandle.high = Math.max(lastCandle.high, data.price);
                        lastCandle.low = Math.min(lastCandle.low, data.price);
                        lastCandle.volume = data.volume;
                    }
                });
                
                // Update UI
                updateChart();
                analyzeTrends();
                lastUpdateEl.textContent = Last update: ${new Date().toLocaleTimeString()};
                updateStatus("Monitoring active");
            } catch (error) {
                console.error("Update error:", error);
                updateStatus(Update failed: ${error.message});
            }
        }

        function getCandleStartTime(date) {
            const d = new Date(date);
            const intervalMs = getIntervalMilliseconds();
            
            // Round down to nearest interval
            return new Date(Math.floor(d.getTime() / intervalMs) * intervalMs);
        }

        function getIntervalMilliseconds() {
            switch (currentInterval) {
                case "4h": return 4 * 60 * 60 * 1000;
                case "1d": return 24 * 60 * 60 * 1000;
                case "1w": return 7 * 24 * 60 * 60 * 1000;
                default: return 4 * 60 * 60 * 1000;
            }
        }

        // ===== TECHNICAL ANALYSIS =====
        function analyzeTrends() {
            const signals = [];
            
            selectedSymbols.forEach(symbol => {
                if (!priceData[symbol] || priceData[symbol].length < 20) return;
                
                const closes = priceData[symbol].map(d => d.close);
                const volumes = priceData[symbol].map(d => d.volume);
                const currentPrice = closes[closes.length - 1];
                
                // 1. Moving Averages
                const ma10 = calculateMA(closes, 10);
                const ma20 = calculateMA(closes, 20);
                const ma50 = calculateMA(closes, 50);
                
                // 2. RSI
                const rsi = calculateRSI(closes, 14);
                
                // 3. Volume Analysis
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                const volumeRatio = volumes[volumes.length - 1] / avgVolume;
                
                // Generate signals
                const symbolSignals = [];
                
                // MA Crossovers
                if (ma10[ma10.length-1] > ma20[ma20.length-1] && ma20[ma20.length-1] > ma50[ma50.length-1]) {
                    symbolSignals.push({ type: 'BUY', reason: 'Bullish MA alignment (10 > 20 > 50)' });
                } else if (ma10[ma10.length-1] < ma20[ma20.length-1] && ma20[ma20.length-1] < ma50[ma50.length-1]) {
                    symbolSignals.push({ type: 'SELL', reason: 'Bearish MA alignment (10 < 20 < 50)' });
                }
                
                // RSI Signals
                if (rsi < 30) symbolSignals.push({ type: 'BUY', reason: RSI Oversold (${rsi.toFixed(1)}) });
                if (rsi > 70) symbolSignals.push({ type: 'SELL', reason: RSI Overbought (${rsi.toFixed(1)}) });
                
                // Volume Spike
                if (volumeRatio > 2) {
                    symbolSignals.push({ 
                        type: volumeRatio > 3 ? 'BUY' : 'NEUTRAL', 
                        reason: Volume spike (${volumeRatio.toFixed(1)}x avg) 
                    });
                }
                
                // Price above/below MAs
                if (currentPrice > ma50[ma50.length-1]) {
                    symbolSignals.push({ type: 'BUY', reason: 'Price above 50-period MA' });
                } else {
                    symbolSignals.push({ type: 'SELL', reason: 'Price below 50-period MA' });
                }
                
                // Add to alerts if we have signals
                if (symbolSignals.length > 0) {
                    signals.push({
                        symbol: symbol,
                        price: currentPrice,
                        signals: symbolSignals,
                        time: new Date()
                    });
                }
            });
            
            updateAlerts(signals);
        }

        function calculateMA(data, period) {
            return data.map((_, i) => {
                if (i < period - 1) return null;
                const slice = data.slice(i - period + 1, i + 1);
                return slice.reduce((a, b) => a + b, 0) / period;
            });
        }

        function calculateRSI(closes, period) {
            let gains = 0;
            let losses = 0;
            
            for (let i = 1; i <= period; i++) {
                const diff = closes[i] - closes[i-1];
                if (diff >= 0) gains += diff;
                else losses -= diff;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        // ===== UI UPDATES =====
        function renderCoinList(filter = '') {
            if (allSymbols.length === 0) {
                coinListEl.innerHTML = '<div class="empty-state">No cryptocurrencies loaded</div>';
                return;
            }
            
            const filteredSymbols = allSymbols.filter(symbol => 
                symbol.toLowerCase().includes(filter.toLowerCase())
            );
            
            if (filteredSymbols.length === 0) {
                coinListEl.innerHTML = '<div class="empty-state">No matching cryptocurrencies</div>';
                return;
            }
            
            coinListEl.innerHTML = '';
            filteredSymbols.forEach(symbol => {
                const coinEl = document.createElement('div');
                coinEl.className = selectedSymbols.includes(symbol) ? 'coin-item selected' : 'coin-item';
                coinEl.textContent = symbol;
                coinEl.addEventListener('click', () => toggleCoinSelection(symbol));
                coinListEl.appendChild(coinEl);
            });
        }

        function toggleCoinSelection(symbol) {
            if (selectedSymbols.includes(symbol)) {
                selectedSymbols = selectedSymbols.filter(s => s !== symbol);
            } else {
                selectedSymbols.push(symbol);
            }
            
            // Update UI
            renderCoinList(coinSearchEl.value);
            updateSelectedCoinsDisplay();
            startBtn.disabled = selectedSymbols.length === 0;
        }

        function updateSelectedCoinsDisplay() {
            if (selectedSymbols.length === 0) {
                selectedCoinsEl.innerHTML = '<div class="empty-state">No coins selected</div>';
                return;
            }
            
            selectedCoinsEl.innerHTML = '';
            selectedSymbols.forEach(symbol => {
                const coinEl = document.createElement('div');
                coinEl.className = 'coin-item selected';
                coinEl.textContent = symbol;
                coinEl.addEventListener('click', () => toggleCoinSelection(symbol));
                selectedCoinsEl.appendChild(coinEl);
            });
        }

        function filterCoins() {
            renderCoinList(coinSearchEl.value);
        }

        function showErrorInCoinList() {
            coinListEl.innerHTML = `
                <div class="empty-state" style="color: var(--danger);">
                    Failed to load. Possible issues:<br>
                    - Network connection problem<br>
                    - Binance API blocked<br>
                    - Ad blocker interfering
                </div>
            `;
        }

        function updateChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            const datasets = [];
            
            // Create a dataset for each selected symbol
            selectedSymbols.forEach((symbol, i) => {
                if (!priceData[symbol] || priceData[symbol].length === 0) return;
                
                const colors = [
                    '#3498db', '#2ecc71', '#e74c3c', '#f39c12', '#9b59b6',
                    '#1abc9c', '#d35400', '#34495e', '#16a085', '#c0392b'
                ];
                
                // Price line
                datasets.push({
                    label: ${symbol} Price,
                    data: priceData[symbol].map(d => d.close),
                    borderColor: colors[i % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
                
                // Moving averages if we have enough data
                if (priceData[symbol].length >= 50) {
                    const closes = priceData[symbol].map(d => d.close);
                    const ma10 = calculateMA(closes, 10);
                    const ma20 = calculateMA(closes, 20);
                    const ma50 = calculateMA(closes, 50);
                    
                    datasets.push({
                        label: ${symbol} MA(10),
                        data: ma10,
                        borderColor: colors[i % colors.length],
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y'
                    });
                    
                    datasets.push({
                        label: ${symbol} MA(20),
                        data: ma20,
                        borderColor: colors[(i + 3) % colors.length],
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y'
                    });
                    
                    datasets.push({
                        label: ${symbol} MA(50),
                        data: ma50,
                        borderColor: colors[(i + 6) % colors.length],
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y'
                    });
                }
                
                // Volume (as a separate axis)
                datasets.push({
                    label: ${symbol} Volume,
                    data: priceData[symbol].map(d => d.volume),
                    backgroundColor: ${colors[i % colors.length]}40,
                    borderColor: 'transparent',
                    type: 'bar',
                    yAxisID: 'y1'
                });
            });
            
            // Create or update chart
            if (chart) {
                chart.data.labels = priceData[selectedSymbols[0]]?.map(d => 
                    d.time.toLocaleDateString([], { month: 'short', day: 'numeric' })
                ) || [];
                chart.data.datasets = datasets;
                chart.update();
            } else {
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: priceData[selectedSymbols[0]]?.map(d => 
                            d.time.toLocaleDateString([], { month: 'short', day: 'numeric' })
                        ) || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: false
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Price (USDT)'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false
                                },
                                title: {
                                    display: true,
                                    text: 'Volume'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 12,
                                    usePointStyle: true
                                }
                            }
                        }
                    }
                });
            }
        }

        function updateAlerts(signals) {
            if (signals.length === 0) {
                alertsEl.innerHTML = '<div class="empty-state">No strong signals detected</div>';
                return;
            }
            
            // Sort by strongest signals first
            signals.sort((a, b) => {
                const aStrength = a.signals.filter(s => s.type === 'BUY' || s.type === 'SELL').length;
                const bStrength = b.signals.filter(s => s.type === 'BUY' || s.type === 'SELL').length;
                return bStrength - aStrength;
            });
            
            let html = '';
            let hasStrongSignal = false;
            
            signals.forEach(signal => {
                const buySignals = signal.signals.filter(s => s.type === 'BUY');
                const sellSignals = signal.signals.filter(s => s.type === 'SELL');
                const neutralSignals = signal.signals.filter(s => s.type === 'NEUTRAL');
                
                if (buySignals.length > 0 || sellSignals.length > 0) {
                    hasStrongSignal = true;
                }
                
                // Group by signal type
                if (buySignals.length > 0) {
                    html += `
                        <div class="alert alert-buy">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="alert-coin">${signal.symbol}</span>
                                <span class="alert-price">$${signal.price.toFixed(4)}</span>
                            </div>
                            ${buySignals.map(s => `
                                <div class="alert-reason">
                                    <strong style="color: var(--success);">BUY:</strong> ${s.reason}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                if (sellSignals.length > 0) {
                    html += `
                        <div class="alert alert-sell">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="alert-coin">${signal.symbol}</span>
                                <span class="alert-price">$${signal.price.toFixed(4)}</span>
                            </div>
                            ${sellSignals.map(s => `
                                <div class="alert-reason">
                                    <strong style="color: var(--danger);">SELL:</strong> ${s.reason}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                if (neutralSignals.length > 0) {
                    html += `
                        <div class="alert alert-neutral">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="alert-coin">${signal.symbol}</span>
                                <span class="alert-price">$${signal.price.toFixed(4)}</span>
                            </div>
                            ${neutralSignals.map(s => `
                                <div class="alert-reason">
                                    <strong>NOTE:</strong> ${s.reason}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            });
            
            alertsEl.innerHTML = html;
            
            // Play sound if we have strong signals
            if (hasStrongSignal) {
                alertSound.play().catch(e => console.log("Audio play failed:", e));
            }
        }

        function updateStatus(text) {
            statusTextEl.textContent = text;
        }

        function showLoading(textElement, spinnerElement, text, show = true) {
            if (show) {
                textElement.textContent = text;
                spinnerElement.style.display = 'inline-block';
            } else {
                textElement.textContent = text;
                spinnerElement.style.display = 'none';
            }
        }
    </script>
</body>
</html>